### 200만 동접 게임을 위한 MYSQL 샤딩



NHN 게임기술센터/ 게임서버엔진팀 전만철

* 2020년 실제 닌텐도의 "Dr.MARIO WORLD" 게임에 적용된 DB 아키텍처에 대한 리뷰글임을 미리 명시함



### 문제상황

![](./image/nhn자료1.png)



* 게임 서버와 db를 연결하는 과정에서 1:1 매핑 구조로 만들 수가 없음

  -> 유저는 게임 서버 중 어느 곳에든 접속할 수 있어야 함

  ​	-> 이를 위해서 게임 서버는 db 중 어느 곳에든 접속이 가능하여 사용자의 정보를 가져올 수 있어야 함

* 이 때 서버의 수와 DB의 수가 증가함으로 인해 각 서버가 DB로 맺는 Connection Pool이 큰 폭으로 증가하게 됨

​		** **Connection Pool** - 데이터베이스로의 추가 요청이 필요할 때 연결을 재사용할 수 있도록 관리되는 데이터베이스 연결의 **캐시**

 			즉 db에 연결되는 Connection을 미리 만들어서 pool 속에 저장해두고 있다가 필요할 때 Connection을 pool에서 쓰고 다시 pool에 반환하는 기법

* Connection이 많아져 서비스가 불가능한 상황이 됨으로 이를 해결하는 것을 목표로 함

* 문제 해결을 위해 투명한 미들웨어가 게임서버와 DB 사이의 관계를 정리해주면 좋겠다고 생각함

  -> 게임 서버가 미들웨어로 요청하면 미들웨어가 그정보를 받아 DB에 접속하는 방법을 1차적으로 구상함

### 해결 방안에 대한 구상

* 새로운 계층(Proxy Layer)에 대한 요구사항

  1) DB에 대한 Connection 관리 및 요구량을 완화 (가장 중요함)

  2. 구현할 필요가 없고 MySQL 프로토콜을 인식해야 함 
  3. Clustering과 Scalability 지원, 고성능이며 오픈소스여야 함
  4. 적용 실패 시 쉽게 fade-out 할 수 있어야 함

  -> 리서치 결과 이 모든 조건의 만족하는 **ProxySQL**을 채택함

### ProxySQL이란?

* MySQL과 호환 DB들을 위한 고성능, 고가용성 프록시로서 MySQL 프로토콜 자체를 인식하여 동작함
* 외부의 connection을 받아 쿼리를 중계해주는 쿼리 라우팅(Query routing) 기능을 핵심으로 하는 proxy database
* 설정되어 있는 backend db에 주기적으로 health check를 보내고 이들 중 하나가 죽으면 auto failover를 해주며 로드 밸런싱과 유사한 기능을 함
* Master/Slave 구조로 인해 데이터베이스가 많은 수로 read replication되어 있는 상태에서 효율적으로 커넥션을 분배해주고, 외부에서 많은 양의 커넥션이 들어오는 경우 효과적으로 connection을 pooling 함

![](./image/nhn자료2.png)

* 서버에서 Proxy SQL을 봤을 때는 MySQL 서버로 인지함

  mysql native protocol을 사용해 쿼리를 던지기 때문

  <-> 백앤드 db에서 봤을 때 ProxySQL은 그냥 appliation임

  ​		쿼리를 던지는 application으로 인식하게 됨

### Connection Multiplexing

* 보통 MySQL이 사용하는 "thread per connection"이 아닌 "**thread pool**" 방법을 사용하여 DB에 대한 connection 수를 극적으로 줄여주는 핵심 기능

  ** **thread per connection**: MySQL 서버는 기본적으로 하나의 클라이언트가 MySQL 서버에 접속할 때마다 해당 클라이언트에 종속적인 thread를 생성하고 해당 커넥션의 thread 역할(쿼리 작업)이 끝나면 thread를 제거함. 

![](./image/nhn자료3.png)

** **thread pool**: 클라이언트의 접속 요청 시 thread를 생성하는 것이 아닌 기존에 생성된 thread를 할당해주어 client 요청에 대한 connection overhead가 없음

* 이를 통해 많은 수의 Front-end connection들을 효율적으로 적은 양의 Back-end connection들로 muxing할 수 있음

** **muxing(다중화)**: 두개 이상의 저수준의 채널들을 하나의 고수준의 채널로 통합하는 과정

![](./image/nhn자료4.png)

* 여러 Game Server로부터 ProxySQL로 오는 커넥션이 multiplexing되어 connection 수가 줄어들음



### Schema 기반의 샤딩

* ProxySQL에서 제공하는 샤딩의 종류로 게임 유저를 정해진 Schema로 샤딩하는 방법

  -> 임의의 게임 유저는 각자의 data가 적재되어 있는 논리 DB로 Rule 기반하여 접근

  ex) 해당 게임유저가 원하는 schema로 쿼리를 던지면 해당 schema에 접근함

### User 기반의 샤딩

* DB 유저를 정해진 MySQL 서버로 샤딩

  -> 임의의 MySQL 서버 유저는 정해진 MySQL 서버로 Rule에 기반하여 샤딩

  ex) 게임 유저가 아닌 DB 유저가 sql 서버를 지정하면 해당 서버로 쿼리가 전송됨



* **DB유저명+스키마명 = 목표 논리 DB ** 

-> 원하는 스키마와 DB유저를 지정하면 여러 db 서버 중에 어떤 곳으로 쿼리가 도달해야 되는지가 결정됨



### 위에 나온 기능들에 대한 코드 예제 설명

![](./image/nhn자료5.png)



* MySQL Client를 통해 admin 계정으로 클러스터링 구성 가능

  -> 4개의 ip에 대해서 해당 ProxySQL 서버들을 클러스터링하고 있음

![](./image/nhn자료6.png)

* 스키마 기반 샤딩과 유저 기반의 샤딩을 혼합한 형태로 query rule을 통해 조작 가능함

* Mysql 유저명을 보통 master와 slave로 나누어 놓음

* RouteDB, UserDB는 유저가 접속할 수 있는 스키마명

  -> 유저명과 DB명을 조합하여 빨간색으로 보이는 hostgroup으로 쿼리를 보내라는 query 규칙이 세워짐



### ProxySQL의 MySQL Replication



** **MySQL Replication(이중화)** : 2대 이상의 DBMS를 나누어 저장하는 방식 -> Master/Slave로 구성됨

* Prx





출처: 

1. https://www.youtube.com/watch?v=8Eb_n7JA1yA
2. https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=ssang8417&logNo=221858327113&categoryNo=24&parentCategoryNo=0&viewDate=&currentPage=1&postListTopCurrentPage=1&from=postView
3. https://planbs.tistory.com/entry/ProxySQL
4. https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jevida&logNo=221272057153